#!/bin/sh

# This tool harvests software metadata from source code repositories and makes it available as codemeta

die() {
    echo "[harvester fatal error] $*">&2
    exit 2
}

error() {
    echo "[harvester error] $*">&2
}

info() {
    echo "[harvester info] $*">&2
}

usage() {
    echo "codemeta-harvester [--cachedir path] [--outputdir path] [CONFIG_FILE_OR_DIRECTORY] ...">&2
}

missing=0
DEPENDENCIES="git sed python3 dasel codemetapy cffconvert"
for dependency in $DEPENDENCIES; do
    if ! command -v "$dependency" >/dev/null 2>/dev/null; then
        error "dependency $dependency not found" && missing=1
    fi
done
[ "$missing" -eq 1 ] && die "there are missing dependencies"

[ -n "$TMPDIR" ] || TMPDIR="/tmp"

CACHEDIR="$TMPDIR/codemeta-harvester.cache/"
OUTPUTDIR=$(realpath .)

while :; do
    case $1 in
        -h|--help)
            usage
            exit
            ;;
        -C|--cachedir)
            CACHEDIR=$2
            shift
            ;;
        -O|--outputdir)
            OUTPUTDIR="$(realpath $2)"
            shift
            ;;
        -?*)
            die "Unknown option: -$1"
            ;;
        *)
            break
    esac

    shift
done

mkdir -p "$CACHEDIR" || die "Unable to create cache directory $CACHEDIR"

harvest() {
    # Harvest metadata from the current directory
    ID="$1"
    if [ -e codemeta.json ]; then
        info "found codemeta for $ID"
        #basic sanity check to see if the codemeta is well-formed (=no syntax errors)
        if dasel -n -f codemeta.json > /dev/null; then
            cp codemeta.json "$OUTPUTDIR/$ID.codemeta.json"
        else
            error "codemeta.json for $ID is not well-formed"
            return 1
        fi
    elif [ -e CITATION.cff ]; then
        info "found CITATION.cff for $ID, converting to codemeta"
        if ! cffconvert -i CITATION.cff -o "$OUTDIR/$ID.codemeta.json" -f codemeta; then
            rm "$OUTDIR/$ID.codemeta.json" 2>/dev/null #clean up possible partial output
            error "CITATION.cff to codemeta conversion for $ID failed"
            return 1
        fi
    elif [ -e setup.py ]; then
        info "found python setup for $ID, converting to codemeta"
        if ! codemetapy --with-entrypoints -O "$OUTPUTDIR/$ID.codemeta.json"; then
            rm "$OUTDIR/$ID.codemeta.json" 2>/dev/null #clean up possible partial output
            error "python setup.py to codemeta conversion failed (codemetapy failed)"
            return 1
        fi
    else
        error "No metadata found for $ID"
        return 1
    fi
}

get_latest_version() {
    #Finds the latest git tag or falls back to returning the git default branch (usually master or main)
    #Assumes some kind of semantic versioning (possibly with a v prefix)
    TAG=$(git tag -l | grep -E "^v?[0-9]+(\.[0-9])*" | sort -t. -k 1.2,1n -k 2,2n -k 3,3n -k 4,4n | tail -n 1)
    if [ -z "$TAG" ]; then
        info "No releases found, falling back to default git branch!"
        git_default_branch
    else
        echo "$TAG"
    fi
}

git_default_branch() {
    #output the git default branch for the repository in the current working dir (usually master or main)
    git symbolic-ref refs/remotes/origin/HEAD | sed 's@^refs/remotes/origin/@@'
}

process() {
    #read a configuration file and harvest the source
    cd "$WORKDIR"
    CONFIGFILE="$1"
    ID=$(basename "$CONFIGFILE" | sed -e 's/\.yaml//' -e 's/\.yml//')
    SOURCEREPO=$(dasel --null -r yaml ".source" < "$CONFIGFILE")
    #Get the requested ref (branch or tag or commit) from the config (if present, otherwise the latest tag will be extracted automatically)
    REF=$(dasel --null -r yaml ".ref" < "$CONFIGFILE")
    if [ -z "$SOURCEREPO" ] || [ "$SOURCEREPO" = "null" ]; then
        die "invalid configuration: $ID"
    fi
    info "Processing $ID ($SOURCEREPO)"
    if [ -d "$CACHEDIR/$ID" ]; then
        cd "$CACHEDIR/$ID" || die "failed to enter directory $CACHEDIR/$ID"
        if git fetch origin --tags; then
            if [ -z "$REF" ] || [ "$REF" = "null" ]; then
                REF=$(get_latest_version)
            fi
            info "Using $REF"
            git -c advice.detachedHead=false checkout "$REF" || die "Invalid git ref '$REF' or unclean working dir"
            harvest "$ID"
        else
            error "Failed to git pull $SOURCEREPO"
            return 1
        fi
    else
        cd "$CACHEDIR" || die "failed to enter cache directory $CACHEDIR"
        if git clone "$SOURCEREPO" "$CACHEDIR/$ID"; then
            cd "$CACHEDIR/$ID" || die "failed to enter dir $CACHEDIR/$ID"
            if [ -z "$REF" ] || [ "$REF" = "null" ]; then
                REF=$(get_latest_version)
            fi
            info "Using $REF for $ID"
            git -c advice.detachedHead=false checkout "$REF" || die "Invalid git ref '$REF' or unclean working dir"
            harvest "$ID"
        else
            error "Failed to git clone $SOURCEREPO"
            return 1
        fi
    fi
}

if [ $# -eq 0 ]; then
    #no configuration provided, just harvest only current project
    ID="$(basename "$(pwd)")"
    harvest "$ID" && mv "$ID.codemeta.json" codemeta.json
else
    #configuration files/directory provided, process them
    WORKDIR=$(pwd)
    for TARGET in "$@"; do
        if [ -f "$TARGET" ]; then
            process "$TARGET"
        elif [ -d "$TARGET" ]; then
            for SUBTARGET in "$TARGET"/*.yml; do
                process "$SUBTARGET"
            done
        fi
    done
fi
