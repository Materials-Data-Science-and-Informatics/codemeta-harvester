#!/bin/sh

# This tool harvests software metadata from source code repositories and makes it available as codemeta

SCRIPTDIR="$(realpath "$(dirname "$0")")"
DEBUG=0

die() {
    DEBUG=1
    flushlog
    echo "[harvester fatal error] $*">&2
    exit 2
}

error() {
    OLDDEBUG=$DEBUG
    DEBUG=1
    flushlog
    DEBUG=$OLDDEBUG
    echo "[harvester error] $*">&2
}

info() {
    echo "[harvester info] $*">&2
}

debug() {
    if [ "$DEBUG" -gt 0 ]; then
        echo "[harvester debug] $*">&2
    fi
}

flushlog() {
    if [ "$DEBUG" -gt 0 ] && [ -e "$TMPLOG" ]; then
        echo "-- begin log --" >&2
        cat "$TMPLOG" >&2
        echo "-- end log --" >&2
        rm "$TMPLOG"
    fi
}

usage() {
    echo "codemeta-harvester [--cachedir path] [--outputdir path] [CONFIG_FILE_OR_DIRECTORY] ...">&2
    echo "   This tool harvests software metadata from source code repositories and makes it available as codemeta."
    echo "   If not file or directory is specified, the harvester will attempt to extract" >&2
    echo "   software metadata for the project in the current working directory and write a codemeta.json file there." >&2
}

missing=0
DEPENDENCIES="git sed python3 dasel codemetapy cffconvert"
for dependency in $DEPENDENCIES; do
    if ! command -v "$dependency" >/dev/null 2>/dev/null; then
        error "dependency $dependency not found" && missing=1
    fi
done
[ "$missing" -eq 1 ] && die "there are missing dependencies"

[ -n "$TMPDIR" ] || TMPDIR="/tmp"

CACHEDIR="$TMPDIR/codemeta-harvester.cache/"
KEEPCACHE=0
OUTPUTDIR=$(realpath .)
CODEMETAPY_ARGS="--all" #enables all recommended extensions

while :; do
    case $1 in
        -h|--help)
            usage
            exit
            ;;
        -C|--cachedir)
            CACHEDIR=$2
            shift
            ;;
        -O|--outputdir)
            OUTPUTDIR="$(realpath "$2")"
            shift
            ;;
        -b|--baseuri)
            CODEMETAPY_ARGS="$CODEMETAPY_ARGS --baseuri $2"
            shift
            ;;
        --keep)
            KEEPCACHE=1
            ;;
        --debug)
            DEBUG=1
            ;;
        -?*)
            die "Unknown option: -$1"
            ;;
        *)
            break
    esac

    shift
done

TMPLOG="$CACHEDIR/codemeta-harvester.debug"

mkdir -p "$CACHEDIR" "$CACHEDIR/tmp" || die "Unable to create cache directory $CACHEDIR"

harvest() {
    # Harvest metadata from the current directory and convert it to codemeta
    ID="$1"
    REF="$2" #git ref
    CODEMETAPY_RECONCILE_ARGS="$3"
    SCANDIRS="$4 ."
    for scandir in $SCANDIRS; do
        oldcwd="$(pwd)"
        [ ! -d "$scandir" ] && continue
        cd "$scandir" || die "Unable to enter $scandir"
        #First we grab all possible metadata and store it in the tmp dir
        if [ -e codemeta.json ]; then
            #If there is an explicit codemeta.json, we will forego on all other detection methods
            #and assume it it the sole authoritative source for metadata.
            info "found codemeta for $ID"
            #basic sanity check to see if the codemeta is well-formed (=no syntax errors)
            if dasel -n -f codemeta.json > /dev/null; then
                cp codemeta.json "$CACHEDIR/tmp/00.$ID.codemeta.json"
                #                               ^-- lowest number indicates highest priority
            else
                error "codemeta.json for $ID is not well-formed"
                return 1
            fi
        else
            #No codemeta found, automatically extract from other sources.
            #(This allows for recombining from multiple sources)

            #If there is a codemeta-harvest.json, we will add it to
            #any other existing metadata that can be found
            if [ -e codemeta-harvest.json ]; then
                info "found codemeta-harvest.json for $ID"
                #basic sanity check to see if the codemeta is well-formed (=no syntax errors)
                if dasel -n -f codemeta-harvest.json > /dev/null; then
                    cp codemeta-harvest.json "$CACHEDIR/tmp/00.$ID.codemeta.json"
                    #                               ^-- lowest number indicates highest priority
                else
                    error "codemeta-harvest.json for $ID is not well-formed"
                    return 1
                fi
            fi

            for f in CITATION.cff CITATION.CFF CITATION; do
                if [ -e "$f" ]; then
                    info "found CITATION.cff for $ID, converting to codemeta"
                    if ! cffconvert -i "$f" -o "$CACHEDIR/tmp/10.$ID.codemeta.json" -f codemeta 2> "$TMPLOG" >&2; then
                        error "CITATION.cff to codemeta conversion for $ID failed"
                        return 1
                    fi
                    flushlog
                    break
                fi
            done

            if [ -e setup.py ] || [ -e pyproject.toml ]; then
                info "found python setup for $ID, converting to codemeta"
                #shellcheck disable=SC2086 #(allow globbing and splitting for $CODEMETAPY_ARGS)
                if ! codemetapy $CODEMETAPY_ARGS -O "$CACHEDIR/tmp/20.$ID.codemeta.json" 2> "$TMPLOG" >&2; then
                    error "python setup.py to codemeta conversion failed (codemetapy failed)"
                    return 1
                fi
                flushlog
            fi

            if [ -e pom.xml ]; then
                info "found pom.xml (Java/Maven) for $ID, converting to codemeta"
                #shellcheck disable=SC2086 #(allow globbing and splitting for $CODEMETAPY_ARGS)
                if ! codemetapy $CODEMETAPY_ARGS -O "$CACHEDIR/tmp/21.$ID.codemeta.json" pom.xml 2> "$TMPLOG" >&2; then
                    error "pom.xml to codemeta conversion failed (codemetapy failed)"
                    return 1
                fi
                flushlog
            fi

            if [ -e package.json ]; then
                info "found package.json (NodeJS) for $ID, converting to codemeta"
                #shellcheck disable=SC2086 #(allow globbing and splitting for $CODEMETAPY_ARGS)
                if ! codemetapy $CODEMETAPY_ARGS -O "$CACHEDIR/tmp/22.$ID.codemeta.json" package.json 2> "$TMPLOG" >&2; then
                    error "package.json to codemeta conversion failed (codemetapy failed)"
                    return 1
                fi
                flushlog
            fi


            [ -e "$SCRIPTDIR/detect-license.sh" ] || die "Unable to find detect-license.sh in $SCRIPTDIR"
            SPDX=$("$SCRIPTDIR/detect-license.sh" 2> "$TMPLOG")
            if [ -n "$SPDX" ]; then
                echo "{ \"license\": \"$SPDX\" }" > "$CACHEDIR/tmp/29.$ID.codemeta.json"
            fi
            flushlog


            GIT_REMOTE_URL=$(git remote get-url origin)
            case "$GIT_REMOTE_URL" in
                https://github.com/*|git@github.com*)
                    #shellcheck disable=SC2086 #(allow globbing and splitting for $CODEMETAPY_ARGS)
                    if ! codemetapy $CODEMETAPY_ARGS -O "$CACHEDIR/tmp/30.$ID.codemeta.json" "$GIT_REMOTE_URL" 2> "$TMPLOG" >&2; then

                        error "conversion from Github API query failed ($GIT_REMOTE_URL) (codemetapy failed)"
                    fi
                    ;;
            esac

            if [ -e README.rst ] && [ ! -e README.md ]; then
                info "Converting README.rst to README.md"
                pandoc README.rst --to gfm -o README.md
            fi

            for f in README.md README README.TXT; do
                if [ -e "$f" ]; then
                    REPOSTATUS=$("$SCRIPTDIR/detect-repostatus.sh" < README.md 2> "$TMPLOG" | head -n 1)
                    if [ -n "$REPOSTATUS" ]; then
                        echo "{ \"developmentStatus\": \"$REPOSTATUS\" }" > "$CACHEDIR/tmp/31.$ID.codemeta.json"
                    fi
                    flushlog
                    break
                fi
            done

            #somef is optional because it relies on many dependencies that not everybody may want:
            if command -v somef 2> /dev/null >&2; then
                for f in README.md README README.TXT;  do
                    if [ -e "$f" ]; then
                        if ! somef describe -c "$CACHEDIR/tmp/40.$ID.codemeta.json" -d "$f" 2> "$TMPLOG" >&2; then
                            error "README to codemeta conversion failed (proceeding regardless!)"
                        fi
                        flushlog
                        break
                    fi
                done
            fi

            cd "$oldcwd" || die "Unable to return to $oldcwd"
        fi
    done

    files=$(ls -r "$CACHEDIR"/tmp/??."$ID".codemeta.json)

    if [ -z "$files" ]; then
        error "No metadata sources found for $ID"
        return 1
    fi

    #Last we reconciliate all metadata using codemetapy
    #this is done in increasing order of priority, where higher priority items (lower number) replace earlier lower priority ones
    info "Reconciliating: codemetapy $CODEMETAPY_ARGS $CODEMETAPY_RECONCILE_ARGS -O \"$OUTPUTDIR/$ID.codemeta.json\" $files"
    #shellcheck disable=SC2086 #(allow globbing and splitting for $CODEMETAPY_*ARGS)
    if ! codemetapy $CODEMETAPY_ARGS $CODEMETAPY_RECONCILE_ARGS -O "$OUTPUTDIR/$ID.codemeta.json" $files 2> "$TMPLOG" >&2; then
        error "Failed to consolidate metadata $ID"
        rm "$OUTDIR/$ID.codemeta.json" 2>/dev/null #clean up possible partial output
        return 1
    else
        flushlog
        info "Output written to $OUTPUTDIR/$ID.codemeta.json"
    fi
    [ $KEEPCACHE -eq 0 ] && rm -rf "$CACHEDIR/tmp/"??".$ID.codemeta.json"
}

harvest_service() {
    # Harvest metadata from a remote service endpoint and add it to the codemeta representation via
    # the "targetProduct" property and one of the software types (https://github.com/codemeta/codemeta/issues/271)
    ID="$1"
    URL="$2"
    info "Harvesting remote service URL $URL for $ID: codemetapy $CODEMETAPY_ARGS -O \"$CACHEDIR/tmp/$ID.codemeta.json\" \"$OUTPUTDIR/$ID.codemeta.json\" \"$URL\""
    #shellcheck disable=SC2086 #(allow globbing and splitting for $CODEMETAPY_ARGS)
    if codemetapy $CODEMETAPY_ARGS -O "$CACHEDIR/tmp/$ID.codemeta.json" "$OUTPUTDIR/$ID.codemeta.json" "$URL" 2> "$TMPLOG" >&2; then
        flushlog
        mv -f "$CACHEDIR/tmp/$ID.codemeta.json" "$OUTPUTDIR/$ID.codemeta.json"
    else
        error "Failed to obtain or process metadata from remote service URL $URL for $ID"
        return 1
    fi
}


get_latest_version() {
    #Finds the latest git tag or falls back to returning the git default branch (usually master or main)
    #Assumes some kind of semantic versioning (possibly with a v prefix)
    TAG=$(git tag -l | grep -E "^v?[0-9]+(\.[0-9])*" | sort -t. -k 1.2,1n -k 2,2n -k 3,3n -k 4,4n | tail -n 1)
    if [ -z "$TAG" ]; then
        info "No releases found, falling back to default git branch!"
        git_default_branch
    else
        echo "$TAG"
    fi
}

git_default_branch() {
    #output the git default branch for the repository in the current working dir (usually master or main)
    git symbolic-ref refs/remotes/origin/HEAD | sed 's@^refs/remotes/origin/@@'
}

process() {
    #read a configuration file and harvest the source
    cd "$WORKDIR" || die "Unable to enter $WORKDIR"
    CONFIGFILE="$1"
    ID=$(basename "$CONFIGFILE" | sed -e 's/\.yaml//' -e 's/\.yml//')
    SOURCEREPO=$(dasel --null -r yaml ".source" < "$CONFIGFILE")
    ROOTPATH=$(dasel --null -r yaml ".root" < "$CONFIGFILE")
    SCANDIRS=$(dasel --null -r yaml --plain ".scandirs" < "$CONFIGFILE" | tr -d "[]")
    SERVICE_URLS=$(dasel --null -r yaml --plain ".services" < "$CONFIGFILE" | tr -d "[]")
    #Get the requested ref (branch or tag or commit) from the config (if present, otherwise the latest tag will be extracted automatically)
    REF=$(dasel --null -r yaml ".ref" < "$CONFIGFILE")
    if [ -z "$SOURCEREPO" ] || [ "$SOURCEREPO" = "null" ]; then
        die "invalid configuration: $ID"
    fi
    info "--> Processing $ID ($SOURCEREPO)"
    CODEMETAPY_RECONCILE_ARGS="--identifier \"$ID\" --codeRepository \"$SOURCEREPO\""
    if [ -d "$CACHEDIR/$ID" ]; then
        cd "$CACHEDIR/$ID" || die "failed to enter directory $CACHEDIR/$ID"
        info "Git updating cached clone of $SOURCEREPO..."
        if git fetch origin --tags 2> "$TMPLOG" >&2; then
            if [ -z "$REF" ] || [ "$REF" = "null" ]; then
                REF=$(get_latest_version)
            fi
            info "Using $REF"
            git -c advice.detachedHead=false checkout "$REF" 2> "$TMPLOG" >&2 || die "Invalid git ref '$REF' or unclean working dir"
            if [ -n "$ROOTPATH" ] && [ "$ROOTPATH" != "null" ]; then
                cd "$ROOTPATH" || die "Unable to enter $ROOTPATH"
            fi
            harvest "$ID" "$REF" "$CODEMETAPY_RECONCILE_ARGS" "$SCANDIRS"
        else
            error "Failed to git pull $SOURCEREPO"
            return 1
        fi
    else
        cd "$CACHEDIR" || die "failed to enter cache directory $CACHEDIR"
        info "Git cloning $SOURCEREPO..."
        if git clone "$SOURCEREPO" "$CACHEDIR/$ID" 2> "$TMPLOG" >&2; then
            cd "$CACHEDIR/$ID" || die "failed to enter dir $CACHEDIR/$ID"
            if [ -z "$REF" ] || [ "$REF" = "null" ]; then
                REF=$(get_latest_version)
            fi
            info "Using $REF for $ID"
            git -c advice.detachedHead=false checkout "$REF"  2> "$TMPLOG" >&2 || die "Invalid git ref '$REF' or unclean working dir"
            if [ -n "$ROOTPATH" ]  && [ "$ROOTPATH" != "null" ]; then
                cd "$ROOTPATH" || die "Unable to enter $ROOTPATH"
            fi
            harvest "$ID" "$REF" "$CODEMETAPY_RECONCILE_ARGS" "$SCANDIRS"
        else
            error "Failed to git clone $SOURCEREPO"
            return 1
        fi
    fi

    #Process services
    if [ -n "$SERVICE_URLS" ] && [ "$SERVICE_URLS" != "null" ]; then
        for URL in $SERVICE_URLS; do
            harvest_service "$ID" "$URL"
        done
    fi

    info "<-- Finished processing $ID ($SOURCEREPO)"
}

if [ $# -eq 0 ]; then
    #no configuration provided, just harvest only current project
    ID="$(basename "$(pwd)")"
    info "Attempting to guess source repo"
    SOURCEREPO=$(git remote get-url origin)
    if [ -n "$SOURCEREPO" ]; then
        info "Source repo is $SOURCEREPO"
        CODEMETAPY_RECONCILE_ARGS="--identifier \"$ID\" --codeRepository \"$SOURCEREPO\""
    else
        CODEMETAPY_RECONCILE_ARGS="--identifier \"$ID\""
    fi
    if harvest "$ID" "" "$CODEMETAPY_RECONCILE_ARGS"; then
        if [ ! -e "codemeta.json" ]; then
            mv "$ID.codemeta.json" codemeta.json && info "Output renamed to $(pwd)/codemeta.json"
        fi
    fi
else
    #configuration files/directory provided, process them
    WORKDIR=$(pwd)
    for TARGET in "$@"; do
        if [ -f "$TARGET" ]; then
            process "$TARGET"
        elif [ -d "$TARGET" ]; then
            for SUBTARGET in "$TARGET"/*.yml; do
                process "$SUBTARGET"
            done
        fi
    done
fi
